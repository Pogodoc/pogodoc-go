/* tslint:disable */
/* eslint-disable */
/**
 * Pogodoc API
 * API for Pogodoc document and template management service. Provides endpoints for rendering documents, managing templates, generating previews, and handling API tokens.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DocumentsImmediateRenderPost200Response
 */
export interface DocumentsImmediateRenderPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DocumentsImmediateRenderPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface DocumentsImmediateRenderPostRequest
 */
export interface DocumentsImmediateRenderPostRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfoType}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'type': TemplatesTemplateIdPutRequestAllOfTemplateInfoType;
    /**
     * 
     * @type {DocumentsInitPostRequestAllOfTarget}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'target': DocumentsInitPostRequestAllOfTarget;
    /**
     * 
     * @type {string}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'templateId'?: string;
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'formatOpts'?: TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts;
    /**
     * 
     * @type {string}
     * @memberof DocumentsImmediateRenderPostRequest
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface DocumentsInitPost200Response
 */
export interface DocumentsInitPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DocumentsInitPost200Response
     */
    'jobId': string;
    /**
     * 
     * @type {DocumentsInitPostRequestAllOfTarget}
     * @memberof DocumentsInitPost200Response
     */
    'target': DocumentsInitPostRequestAllOfTarget;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInitPost200Response
     */
    'presignedDataUploadUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInitPost200Response
     */
    'presignedTemplateUploadUrl': string | null;
}
/**
 * 
 * @export
 * @interface DocumentsInitPostRequest
 */
export interface DocumentsInitPostRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentsInitPostRequest
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfoType}
     * @memberof DocumentsInitPostRequest
     */
    'type': TemplatesTemplateIdPutRequestAllOfTemplateInfoType;
    /**
     * 
     * @type {DocumentsInitPostRequestAllOfTarget}
     * @memberof DocumentsInitPostRequest
     */
    'target': DocumentsInitPostRequestAllOfTarget;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInitPostRequest
     */
    'templateId'?: string;
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts}
     * @memberof DocumentsInitPostRequest
     */
    'formatOpts'?: TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts;
}
/**
 * 
 * @export
 * @interface DocumentsInitPostRequestAllOfTarget
 */
export interface DocumentsInitPostRequestAllOfTarget {
}
/**
 * 
 * @export
 * @interface DocumentsJobIdRenderPost200Response
 */
export interface DocumentsJobIdRenderPost200Response {
    /**
     * 
     * @type {string}
     * @memberof DocumentsJobIdRenderPost200Response
     */
    'jobId': string;
}
/**
 * 
 * @export
 * @interface DocumentsJobIdRenderPostRequest
 */
export interface DocumentsJobIdRenderPostRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DocumentsJobIdRenderPostRequest
     */
    'shouldWaitForRenderCompletion'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentsJobIdRenderPostRequest
     */
    'uploadPresignedS3Url'?: string;
}
/**
 * 
 * @export
 * @interface JobsJobIdGet200Response
 */
export interface JobsJobIdGet200Response {
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfoType}
     * @memberof JobsJobIdGet200Response
     */
    'type': TemplatesTemplateIdPutRequestAllOfTemplateInfoType;
    /**
     * 
     * @type {string}
     * @memberof JobsJobIdGet200Response
     */
    'jobId': string;
    /**
     * 
     * @type {DocumentsInitPostRequestAllOfTarget}
     * @memberof JobsJobIdGet200Response
     */
    'target': DocumentsInitPostRequestAllOfTarget;
    /**
     * 
     * @type {JobsJobIdGet200ResponseOutput}
     * @memberof JobsJobIdGet200Response
     */
    'output'?: JobsJobIdGet200ResponseOutput;
    /**
     * 
     * @type {boolean}
     * @memberof JobsJobIdGet200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobsJobIdGet200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface JobsJobIdGet200ResponseOutput
 */
export interface JobsJobIdGet200ResponseOutput {
    /**
     * 
     * @type {DocumentsImmediateRenderPost200Response}
     * @memberof JobsJobIdGet200ResponseOutput
     */
    'data': DocumentsImmediateRenderPost200Response;
    /**
     * 
     * @type {JobsJobIdGet200ResponseOutputMetadata}
     * @memberof JobsJobIdGet200ResponseOutput
     */
    'metadata': JobsJobIdGet200ResponseOutputMetadata;
}
/**
 * 
 * @export
 * @interface JobsJobIdGet200ResponseOutputMetadata
 */
export interface JobsJobIdGet200ResponseOutputMetadata {
    /**
     * 
     * @type {number}
     * @memberof JobsJobIdGet200ResponseOutputMetadata
     */
    'renderTime': number;
}
/**
 * 
 * @export
 * @interface TemplatesInitGet200Response
 */
export interface TemplatesInitGet200Response {
    /**
     * 
     * @type {string}
     * @memberof TemplatesInitGet200Response
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplatesInitGet200Response
     */
    'presignedTemplateUploadUrl': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdClonePost200Response
 */
export interface TemplatesTemplateIdClonePost200Response {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdClonePost200Response
     */
    'newTemplateId': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdIndexHtmlGet200Response
 */
export interface TemplatesTemplateIdIndexHtmlGet200Response {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdIndexHtmlGet200Response
     */
    'templateIndex': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPostRequest
 */
export interface TemplatesTemplateIdPostRequest {
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfo}
     * @memberof TemplatesTemplateIdPostRequest
     */
    'templateInfo': TemplatesTemplateIdPutRequestAllOfTemplateInfo;
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfPreviewIds}
     * @memberof TemplatesTemplateIdPostRequest
     */
    'previewIds': TemplatesTemplateIdPutRequestAllOfPreviewIds;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPresignedUrlGet200Response
 */
export interface TemplatesTemplateIdPresignedUrlGet200Response {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPresignedUrlGet200Response
     */
    'presignedUrl': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPut200Response
 */
export interface TemplatesTemplateIdPut200Response {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPut200Response
     */
    'newContentId': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPutRequest
 */
export interface TemplatesTemplateIdPutRequest {
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfo}
     * @memberof TemplatesTemplateIdPutRequest
     */
    'templateInfo': TemplatesTemplateIdPutRequestAllOfTemplateInfo;
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfPreviewIds}
     * @memberof TemplatesTemplateIdPutRequest
     */
    'previewIds': TemplatesTemplateIdPutRequestAllOfPreviewIds;
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequest
     */
    'contentId': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPutRequestAllOfPreviewIds
 */
export interface TemplatesTemplateIdPutRequestAllOfPreviewIds {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequestAllOfPreviewIds
     */
    'pngJobId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequestAllOfPreviewIds
     */
    'pdfJobId': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPutRequestAllOfTemplateInfo
 */
export interface TemplatesTemplateIdPutRequestAllOfTemplateInfo {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'description': string;
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfoType}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'type': TemplatesTemplateIdPutRequestAllOfTemplateInfoType;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'sampleData': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'sourceCode'?: string;
    /**
     * 
     * @type {Array<TemplatesTemplateIdPutRequestAllOfTemplateInfoCategoriesInner>}
     * @memberof TemplatesTemplateIdPutRequestAllOfTemplateInfo
     */
    'categories': Array<TemplatesTemplateIdPutRequestAllOfTemplateInfoCategoriesInner>;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPutRequestAllOfTemplateInfoCategoriesInner
 */
export interface TemplatesTemplateIdPutRequestAllOfTemplateInfoCategoriesInner {
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdPutRequestAllOfTemplateInfoType
 */
export interface TemplatesTemplateIdPutRequestAllOfTemplateInfoType {
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdRenderPreviewsPost200Response
 */
export interface TemplatesTemplateIdRenderPreviewsPost200Response {
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview}
     * @memberof TemplatesTemplateIdRenderPreviewsPost200Response
     */
    'pngPreview': TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview;
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview}
     * @memberof TemplatesTemplateIdRenderPreviewsPost200Response
     */
    'pdfPreview': TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview
 */
export interface TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview
     */
    'jobId': string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdRenderPreviewsPostRequest
 */
export interface TemplatesTemplateIdRenderPreviewsPostRequest {
    /**
     * 
     * @type {TemplatesTemplateIdPutRequestAllOfTemplateInfoType}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequest
     */
    'type': TemplatesTemplateIdPutRequestAllOfTemplateInfoType;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequest
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequest
     */
    'formatOpts'?: TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts
 */
export interface TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts {
    /**
     * 
     * @type {number}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts
     */
    'fromPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts
     */
    'toPage'?: number;
    /**
     * 
     * @type {TemplatesTemplateIdRenderPreviewsPostRequestFormatOptsAllOfFormat}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts
     */
    'format'?: TemplatesTemplateIdRenderPreviewsPostRequestFormatOptsAllOfFormat;
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdRenderPreviewsPostRequestFormatOpts
     */
    'waitForSelector'?: string;
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdRenderPreviewsPostRequestFormatOptsAllOfFormat
 */
export interface TemplatesTemplateIdRenderPreviewsPostRequestFormatOptsAllOfFormat {
}
/**
 * 
 * @export
 * @interface TemplatesTemplateIdUnzipPostRequest
 */
export interface TemplatesTemplateIdUnzipPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesTemplateIdUnzipPostRequest
     */
    'templateId': string;
}

/**
 * RenderApi - axios parameter creator
 * @export
 */
export const RenderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Combines initialization and rendering in one step. Creates a job, uploads template/data directly, starts rendering, and adds the document to Strapi. Requires subscription check.
         * @summary Immediate Render
         * @param {DocumentsImmediateRenderPostRequest} [documentsImmediateRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsImmediateRenderPost: async (documentsImmediateRenderPostRequest?: DocumentsImmediateRenderPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/immediate-render`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentsImmediateRenderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new render job with a unique ID, sets up S3 storage for template and data files, and generates presigned upload URLs if needed. Requires subscription check.
         * @summary Initialize Render Job
         * @param {DocumentsInitPostRequest} [documentsInitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsInitPost: async (documentsInitPostRequest?: DocumentsInitPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentsInitPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a previously initialized job, updates its status to in-progress, and triggers the rendering process using Puppeteer. Can optionally wait for render completion.
         * @summary Start Render Job
         * @param {string} jobId 
         * @param {DocumentsJobIdRenderPostRequest} [documentsJobIdRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsJobIdRenderPost: async (jobId: string, documentsJobIdRenderPostRequest?: DocumentsJobIdRenderPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('documentsJobIdRenderPost', 'jobId', jobId)
            const localVarPath = `/documents/{jobId}/render`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentsJobIdRenderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a preview by creating a single-page render job, processing it immediately, and returning the output URL. Used for template visualization.
         * @summary Generate Document Preview
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRenderPreviewPost: async (templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('documentsRenderPreviewPost', 'templateId', templateId)
            // verify required parameter 'templatesTemplateIdRenderPreviewsPostRequest' is not null or undefined
            assertParamExists('documentsRenderPreviewPost', 'templatesTemplateIdRenderPreviewsPostRequest', templatesTemplateIdRenderPreviewsPostRequest)
            const localVarPath = `/documents/render-preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdRenderPreviewsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches detailed job information from S3 storage including job status, template ID, target format, and output details if available.
         * @summary Get Job Status
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdGet: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobsJobIdGet', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RenderApi - functional programming interface
 * @export
 */
export const RenderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RenderApiAxiosParamCreator(configuration)
    return {
        /**
         * Combines initialization and rendering in one step. Creates a job, uploads template/data directly, starts rendering, and adds the document to Strapi. Requires subscription check.
         * @summary Immediate Render
         * @param {DocumentsImmediateRenderPostRequest} [documentsImmediateRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsImmediateRenderPost(documentsImmediateRenderPostRequest?: DocumentsImmediateRenderPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsImmediateRenderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsImmediateRenderPost(documentsImmediateRenderPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RenderApi.documentsImmediateRenderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new render job with a unique ID, sets up S3 storage for template and data files, and generates presigned upload URLs if needed. Requires subscription check.
         * @summary Initialize Render Job
         * @param {DocumentsInitPostRequest} [documentsInitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsInitPost(documentsInitPostRequest?: DocumentsInitPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsInitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsInitPost(documentsInitPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RenderApi.documentsInitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a previously initialized job, updates its status to in-progress, and triggers the rendering process using Puppeteer. Can optionally wait for render completion.
         * @summary Start Render Job
         * @param {string} jobId 
         * @param {DocumentsJobIdRenderPostRequest} [documentsJobIdRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsJobIdRenderPost(jobId: string, documentsJobIdRenderPostRequest?: DocumentsJobIdRenderPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsJobIdRenderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsJobIdRenderPost(jobId, documentsJobIdRenderPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RenderApi.documentsJobIdRenderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a preview by creating a single-page render job, processing it immediately, and returning the output URL. Used for template visualization.
         * @summary Generate Document Preview
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsRenderPreviewPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsRenderPreviewPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RenderApi.documentsRenderPreviewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches detailed job information from S3 storage including job status, template ID, target format, and output details if available.
         * @summary Get Job Status
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobsJobIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RenderApi.jobsJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RenderApi - factory interface
 * @export
 */
export const RenderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RenderApiFp(configuration)
    return {
        /**
         * Combines initialization and rendering in one step. Creates a job, uploads template/data directly, starts rendering, and adds the document to Strapi. Requires subscription check.
         * @summary Immediate Render
         * @param {DocumentsImmediateRenderPostRequest} [documentsImmediateRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsImmediateRenderPost(documentsImmediateRenderPostRequest?: DocumentsImmediateRenderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsImmediateRenderPost200Response> {
            return localVarFp.documentsImmediateRenderPost(documentsImmediateRenderPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new render job with a unique ID, sets up S3 storage for template and data files, and generates presigned upload URLs if needed. Requires subscription check.
         * @summary Initialize Render Job
         * @param {DocumentsInitPostRequest} [documentsInitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsInitPost(documentsInitPostRequest?: DocumentsInitPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsInitPost200Response> {
            return localVarFp.documentsInitPost(documentsInitPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a previously initialized job, updates its status to in-progress, and triggers the rendering process using Puppeteer. Can optionally wait for render completion.
         * @summary Start Render Job
         * @param {string} jobId 
         * @param {DocumentsJobIdRenderPostRequest} [documentsJobIdRenderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsJobIdRenderPost(jobId: string, documentsJobIdRenderPostRequest?: DocumentsJobIdRenderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsJobIdRenderPost200Response> {
            return localVarFp.documentsJobIdRenderPost(jobId, documentsJobIdRenderPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a preview by creating a single-page render job, processing it immediately, and returning the output URL. Used for template visualization.
         * @summary Generate Document Preview
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRenderPreviewPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdRenderPreviewsPost200ResponsePngPreview> {
            return localVarFp.documentsRenderPreviewPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches detailed job information from S3 storage including job status, template ID, target format, and output details if available.
         * @summary Get Job Status
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobsJobIdGet200Response> {
            return localVarFp.jobsJobIdGet(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RenderApi - object-oriented interface
 * @export
 * @class RenderApi
 * @extends {BaseAPI}
 */
export class RenderApi extends BaseAPI {
    /**
     * Combines initialization and rendering in one step. Creates a job, uploads template/data directly, starts rendering, and adds the document to Strapi. Requires subscription check.
     * @summary Immediate Render
     * @param {DocumentsImmediateRenderPostRequest} [documentsImmediateRenderPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RenderApi
     */
    public documentsImmediateRenderPost(documentsImmediateRenderPostRequest?: DocumentsImmediateRenderPostRequest, options?: RawAxiosRequestConfig) {
        return RenderApiFp(this.configuration).documentsImmediateRenderPost(documentsImmediateRenderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new render job with a unique ID, sets up S3 storage for template and data files, and generates presigned upload URLs if needed. Requires subscription check.
     * @summary Initialize Render Job
     * @param {DocumentsInitPostRequest} [documentsInitPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RenderApi
     */
    public documentsInitPost(documentsInitPostRequest?: DocumentsInitPostRequest, options?: RawAxiosRequestConfig) {
        return RenderApiFp(this.configuration).documentsInitPost(documentsInitPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a previously initialized job, updates its status to in-progress, and triggers the rendering process using Puppeteer. Can optionally wait for render completion.
     * @summary Start Render Job
     * @param {string} jobId 
     * @param {DocumentsJobIdRenderPostRequest} [documentsJobIdRenderPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RenderApi
     */
    public documentsJobIdRenderPost(jobId: string, documentsJobIdRenderPostRequest?: DocumentsJobIdRenderPostRequest, options?: RawAxiosRequestConfig) {
        return RenderApiFp(this.configuration).documentsJobIdRenderPost(jobId, documentsJobIdRenderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a preview by creating a single-page render job, processing it immediately, and returning the output URL. Used for template visualization.
     * @summary Generate Document Preview
     * @param {string} templateId 
     * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RenderApi
     */
    public documentsRenderPreviewPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig) {
        return RenderApiFp(this.configuration).documentsRenderPreviewPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches detailed job information from S3 storage including job status, template ID, target format, and output details if available.
     * @summary Get Job Status
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RenderApi
     */
    public jobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig) {
        return RenderApiFp(this.configuration).jobsJobIdGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initializes template creation by generating a unique ID and providing a presigned URL for template ZIP upload. Sets unfinished tag for tracking incomplete templates.
         * @summary Initialize Template Creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesInitGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new template by duplicating an existing template\'s content and metadata. Includes copying preview files and template index.
         * @summary Clone Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdClonePost: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdClonePost', 'templateId', templateId)
            const localVarPath = `/templates/{templateId}/clone`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a template from Strapi and associated S3 storage. Removes all associated files and metadata.
         * @summary Delete Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdDelete: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdDelete', 'templateId', templateId)
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the template index.html file from S3 storage. Used for rendering the template in the browser.
         * @summary Get Template Index HTML
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdIndexHtmlGet: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdIndexHtmlGet', 'templateId', templateId)
            const localVarPath = `/templates/{templateId}/index-html`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads the template index.html file to S3 storage. Used for rendering the template in the browser.
         * @summary Upload Template Index HTML
         * @param {string} templateId 
         * @param {TemplatesTemplateIdIndexHtmlGet200Response} templatesTemplateIdIndexHtmlGet200Response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdIndexHtmlPost: async (templateId: string, templatesTemplateIdIndexHtmlGet200Response: TemplatesTemplateIdIndexHtmlGet200Response, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdIndexHtmlPost', 'templateId', templateId)
            // verify required parameter 'templatesTemplateIdIndexHtmlGet200Response' is not null or undefined
            assertParamExists('templatesTemplateIdIndexHtmlPost', 'templatesTemplateIdIndexHtmlGet200Response', templatesTemplateIdIndexHtmlGet200Response)
            const localVarPath = `/templates/{templateId}/index-html`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdIndexHtmlGet200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalizes template creation by saving template info to Strapi, copying preview files to permanent storage, and creating template index. Removes unfinished tag upon completion.
         * @summary Save New Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPostRequest} templatesTemplateIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPost: async (templateId: string, templatesTemplateIdPostRequest: TemplatesTemplateIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdPost', 'templateId', templateId)
            // verify required parameter 'templatesTemplateIdPostRequest' is not null or undefined
            assertParamExists('templatesTemplateIdPost', 'templatesTemplateIdPostRequest', templatesTemplateIdPostRequest)
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a presigned URL for template access. Used for downloading template files from S3 storage.
         * @summary Generate Presigned URL
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPresignedUrlGet: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdPresignedUrlGet', 'templateId', templateId)
            const localVarPath = `/templates/{templateId}/presigned-url`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates template content, handles S3 storage cleanup for old content, updates template metadata in Strapi, and manages preview files. Removes unfinished tags after successful update.
         * @summary Update Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPutRequest} [templatesTemplateIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPut: async (templateId: string, templatesTemplateIdPutRequest?: TemplatesTemplateIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdPut', 'templateId', templateId)
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates both PNG and PDF preview files for template visualization. Generates previews in parallel and returns URLs for both formats.
         * @summary Generate Template Previews
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdRenderPreviewsPost: async (templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdRenderPreviewsPost', 'templateId', templateId)
            // verify required parameter 'templatesTemplateIdRenderPreviewsPostRequest' is not null or undefined
            assertParamExists('templatesTemplateIdRenderPreviewsPost', 'templatesTemplateIdRenderPreviewsPostRequest', templatesTemplateIdRenderPreviewsPostRequest)
            const localVarPath = `/templates/{templateId}/render-previews`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdRenderPreviewsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extracts contents from an uploaded template ZIP file and stores individual files in the appropriate S3 storage structure.
         * @summary Extract Template Files
         * @param {string} templateId 
         * @param {TemplatesTemplateIdUnzipPostRequest} templatesTemplateIdUnzipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdUnzipPost: async (templateId: string, templatesTemplateIdUnzipPostRequest: TemplatesTemplateIdUnzipPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesTemplateIdUnzipPost', 'templateId', templateId)
            // verify required parameter 'templatesTemplateIdUnzipPostRequest' is not null or undefined
            assertParamExists('templatesTemplateIdUnzipPost', 'templatesTemplateIdUnzipPostRequest', templatesTemplateIdUnzipPostRequest)
            const localVarPath = `/templates/{templateId}/unzip`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesTemplateIdUnzipPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Initializes template creation by generating a unique ID and providing a presigned URL for template ZIP upload. Sets unfinished tag for tracking incomplete templates.
         * @summary Initialize Template Creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesInitGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesInitGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesInitGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesInitGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new template by duplicating an existing template\'s content and metadata. Includes copying preview files and template index.
         * @summary Clone Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdClonePost(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdClonePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdClonePost(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a template from Strapi and associated S3 storage. Removes all associated files and metadata.
         * @summary Delete Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdDelete(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdDelete(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the template index.html file from S3 storage. Used for rendering the template in the browser.
         * @summary Get Template Index HTML
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdIndexHtmlGet(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdIndexHtmlGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdIndexHtmlGet(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdIndexHtmlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads the template index.html file to S3 storage. Used for rendering the template in the browser.
         * @summary Upload Template Index HTML
         * @param {string} templateId 
         * @param {TemplatesTemplateIdIndexHtmlGet200Response} templatesTemplateIdIndexHtmlGet200Response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdIndexHtmlPost(templateId: string, templatesTemplateIdIndexHtmlGet200Response: TemplatesTemplateIdIndexHtmlGet200Response, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdIndexHtmlPost(templateId, templatesTemplateIdIndexHtmlGet200Response, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdIndexHtmlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finalizes template creation by saving template info to Strapi, copying preview files to permanent storage, and creating template index. Removes unfinished tag upon completion.
         * @summary Save New Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPostRequest} templatesTemplateIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdPost(templateId: string, templatesTemplateIdPostRequest: TemplatesTemplateIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdPost(templateId, templatesTemplateIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a presigned URL for template access. Used for downloading template files from S3 storage.
         * @summary Generate Presigned URL
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdPresignedUrlGet(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdPresignedUrlGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdPresignedUrlGet(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdPresignedUrlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates template content, handles S3 storage cleanup for old content, updates template metadata in Strapi, and manages preview files. Removes unfinished tags after successful update.
         * @summary Update Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPutRequest} [templatesTemplateIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdPut(templateId: string, templatesTemplateIdPutRequest?: TemplatesTemplateIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdPut(templateId, templatesTemplateIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates both PNG and PDF preview files for template visualization. Generates previews in parallel and returns URLs for both formats.
         * @summary Generate Template Previews
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdRenderPreviewsPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesTemplateIdRenderPreviewsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdRenderPreviewsPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdRenderPreviewsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extracts contents from an uploaded template ZIP file and stores individual files in the appropriate S3 storage structure.
         * @summary Extract Template Files
         * @param {string} templateId 
         * @param {TemplatesTemplateIdUnzipPostRequest} templatesTemplateIdUnzipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesTemplateIdUnzipPost(templateId: string, templatesTemplateIdUnzipPostRequest: TemplatesTemplateIdUnzipPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesTemplateIdUnzipPost(templateId, templatesTemplateIdUnzipPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesTemplateIdUnzipPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Initializes template creation by generating a unique ID and providing a presigned URL for template ZIP upload. Sets unfinished tag for tracking incomplete templates.
         * @summary Initialize Template Creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesInitGet(options?: RawAxiosRequestConfig): AxiosPromise<TemplatesInitGet200Response> {
            return localVarFp.templatesInitGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new template by duplicating an existing template\'s content and metadata. Includes copying preview files and template index.
         * @summary Clone Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdClonePost(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdClonePost200Response> {
            return localVarFp.templatesTemplateIdClonePost(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a template from Strapi and associated S3 storage. Removes all associated files and metadata.
         * @summary Delete Template
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdDelete(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesTemplateIdDelete(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the template index.html file from S3 storage. Used for rendering the template in the browser.
         * @summary Get Template Index HTML
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdIndexHtmlGet(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdIndexHtmlGet200Response> {
            return localVarFp.templatesTemplateIdIndexHtmlGet(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads the template index.html file to S3 storage. Used for rendering the template in the browser.
         * @summary Upload Template Index HTML
         * @param {string} templateId 
         * @param {TemplatesTemplateIdIndexHtmlGet200Response} templatesTemplateIdIndexHtmlGet200Response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdIndexHtmlPost(templateId: string, templatesTemplateIdIndexHtmlGet200Response: TemplatesTemplateIdIndexHtmlGet200Response, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesTemplateIdIndexHtmlPost(templateId, templatesTemplateIdIndexHtmlGet200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalizes template creation by saving template info to Strapi, copying preview files to permanent storage, and creating template index. Removes unfinished tag upon completion.
         * @summary Save New Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPostRequest} templatesTemplateIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPost(templateId: string, templatesTemplateIdPostRequest: TemplatesTemplateIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesTemplateIdPost(templateId, templatesTemplateIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a presigned URL for template access. Used for downloading template files from S3 storage.
         * @summary Generate Presigned URL
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPresignedUrlGet(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdPresignedUrlGet200Response> {
            return localVarFp.templatesTemplateIdPresignedUrlGet(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates template content, handles S3 storage cleanup for old content, updates template metadata in Strapi, and manages preview files. Removes unfinished tags after successful update.
         * @summary Update Template
         * @param {string} templateId 
         * @param {TemplatesTemplateIdPutRequest} [templatesTemplateIdPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdPut(templateId: string, templatesTemplateIdPutRequest?: TemplatesTemplateIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdPut200Response> {
            return localVarFp.templatesTemplateIdPut(templateId, templatesTemplateIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates both PNG and PDF preview files for template visualization. Generates previews in parallel and returns URLs for both formats.
         * @summary Generate Template Previews
         * @param {string} templateId 
         * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdRenderPreviewsPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesTemplateIdRenderPreviewsPost200Response> {
            return localVarFp.templatesTemplateIdRenderPreviewsPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Extracts contents from an uploaded template ZIP file and stores individual files in the appropriate S3 storage structure.
         * @summary Extract Template Files
         * @param {string} templateId 
         * @param {TemplatesTemplateIdUnzipPostRequest} templatesTemplateIdUnzipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesTemplateIdUnzipPost(templateId: string, templatesTemplateIdUnzipPostRequest: TemplatesTemplateIdUnzipPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.templatesTemplateIdUnzipPost(templateId, templatesTemplateIdUnzipPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Initializes template creation by generating a unique ID and providing a presigned URL for template ZIP upload. Sets unfinished tag for tracking incomplete templates.
     * @summary Initialize Template Creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesInitGet(options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesInitGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new template by duplicating an existing template\'s content and metadata. Includes copying preview files and template index.
     * @summary Clone Template
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdClonePost(templateId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdClonePost(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a template from Strapi and associated S3 storage. Removes all associated files and metadata.
     * @summary Delete Template
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdDelete(templateId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdDelete(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the template index.html file from S3 storage. Used for rendering the template in the browser.
     * @summary Get Template Index HTML
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdIndexHtmlGet(templateId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdIndexHtmlGet(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads the template index.html file to S3 storage. Used for rendering the template in the browser.
     * @summary Upload Template Index HTML
     * @param {string} templateId 
     * @param {TemplatesTemplateIdIndexHtmlGet200Response} templatesTemplateIdIndexHtmlGet200Response 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdIndexHtmlPost(templateId: string, templatesTemplateIdIndexHtmlGet200Response: TemplatesTemplateIdIndexHtmlGet200Response, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdIndexHtmlPost(templateId, templatesTemplateIdIndexHtmlGet200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalizes template creation by saving template info to Strapi, copying preview files to permanent storage, and creating template index. Removes unfinished tag upon completion.
     * @summary Save New Template
     * @param {string} templateId 
     * @param {TemplatesTemplateIdPostRequest} templatesTemplateIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdPost(templateId: string, templatesTemplateIdPostRequest: TemplatesTemplateIdPostRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdPost(templateId, templatesTemplateIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a presigned URL for template access. Used for downloading template files from S3 storage.
     * @summary Generate Presigned URL
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdPresignedUrlGet(templateId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdPresignedUrlGet(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates template content, handles S3 storage cleanup for old content, updates template metadata in Strapi, and manages preview files. Removes unfinished tags after successful update.
     * @summary Update Template
     * @param {string} templateId 
     * @param {TemplatesTemplateIdPutRequest} [templatesTemplateIdPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdPut(templateId: string, templatesTemplateIdPutRequest?: TemplatesTemplateIdPutRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdPut(templateId, templatesTemplateIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates both PNG and PDF preview files for template visualization. Generates previews in parallel and returns URLs for both formats.
     * @summary Generate Template Previews
     * @param {string} templateId 
     * @param {TemplatesTemplateIdRenderPreviewsPostRequest} templatesTemplateIdRenderPreviewsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdRenderPreviewsPost(templateId: string, templatesTemplateIdRenderPreviewsPostRequest: TemplatesTemplateIdRenderPreviewsPostRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdRenderPreviewsPost(templateId, templatesTemplateIdRenderPreviewsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extracts contents from an uploaded template ZIP file and stores individual files in the appropriate S3 storage structure.
     * @summary Extract Template Files
     * @param {string} templateId 
     * @param {TemplatesTemplateIdUnzipPostRequest} templatesTemplateIdUnzipPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesTemplateIdUnzipPost(templateId: string, templatesTemplateIdUnzipPostRequest: TemplatesTemplateIdUnzipPostRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesTemplateIdUnzipPost(templateId, templatesTemplateIdUnzipPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invalidates an API token by storing it in the deleted tokens S3 bucket, preventing future use of the token for authentication.
         * @summary Delete API Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokensTokenIdDelete: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('apiTokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/api-tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Invalidates an API token by storing it in the deleted tokens S3 bucket, preventing future use of the token for authentication.
         * @summary Delete API Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokensTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokensTokenIdDelete(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.apiTokensTokenIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * Invalidates an API token by storing it in the deleted tokens S3 bucket, preventing future use of the token for authentication.
         * @summary Delete API Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokensTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.apiTokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * Invalidates an API token by storing it in the deleted tokens S3 bucket, preventing future use of the token for authentication.
     * @summary Delete API Token
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public apiTokensTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).apiTokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



